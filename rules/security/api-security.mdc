---
description: API security standards for protecting endpoints against common attacks. This rule covers rate limiting, CORS configuration, CSRF protection, security headers, and API versioning. Agents must implement rate limiting on all public endpoints, configure CORS properly, add security headers, protect against CSRF attacks, and implement proper API versioning for backward compatibility.
version: 1.0.0
created: 12-08-2025
lastUpdated: 12-08-2025 10:00:00 EST
alwaysApply: false
globs: **/api/**,**/routes/**,**/middleware/**
type: Security Rule - API security standards
applicability: API development and review
dependencies: []
relatedCommands: [[audit-security.md]]
relatedRules: [[authentication.mdc], [input-validation.mdc], [../api/api-routes.mdc]]
relatedStandards: []
---

# API Security Rule

## When This Rule Applies

This rule applies when:
- Building API endpoints
- Configuring API middleware
- Reviewing API security
- Setting up rate limiting and CORS

---

## Core Principles

1. **Defense in depth** - Multiple security layers
2. **Secure by default** - Restrictive defaults
3. **Fail securely** - Errors don't expose internals
4. **Log everything** - Audit trail for security events

---

## Security Standards

### 1. Rate Limiting

**Implement on all public endpoints:**

```typescript
import rateLimit from 'express-rate-limit';

// General API rate limit
const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // 100 requests per window
  standardHeaders: true,
  legacyHeaders: false,
  message: { error: 'Too many requests, please try again later' },
});

// Stricter limit for auth endpoints
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5, // Only 5 attempts
  skipSuccessfulRequests: true,
});

app.use('/api', apiLimiter);
app.use('/api/auth', authLimiter);
```

### 2. CORS Configuration

**Configure properly for your use case:**

```typescript
import cors from 'cors';

// Strict CORS for production
const corsOptions: cors.CorsOptions = {
  origin: process.env.ALLOWED_ORIGINS?.split(',') || ['https://yourdomain.com'],
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  credentials: true,
  maxAge: 86400, // 24 hours
};

app.use(cors(corsOptions));
```

### 3. Security Headers

**Use helmet or equivalent:**

```typescript
import helmet from 'helmet';

app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      imgSrc: ["'self'", 'data:', 'https:'],
    },
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true,
  },
}));

// Manual headers if not using helmet
app.use((req, res, next) => {
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.setHeader('X-Frame-Options', 'DENY');
  res.setHeader('X-XSS-Protection', '1; mode=block');
  res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');
  next();
});
```

### 4. CSRF Protection

**For state-changing operations:**

```typescript
import csrf from 'csurf';

// Enable CSRF for non-API routes
app.use('/app', csrf({ cookie: true }));

// Include token in forms
app.get('/form', (req, res) => {
  res.render('form', { csrfToken: req.csrfToken() });
});
```

### 5. Request Size Limits

**Prevent payload attacks:**

```typescript
import express from 'express';

app.use(express.json({ limit: '10kb' }));
app.use(express.urlencoded({ extended: true, limit: '10kb' }));
```

### 6. API Versioning

**Support backward compatibility:**

```typescript
// URL versioning
app.use('/api/v1', v1Router);
app.use('/api/v2', v2Router);

// Header versioning
app.use('/api', (req, res, next) => {
  const version = req.header('API-Version') || 'v1';
  req.apiVersion = version;
  next();
});
```

---

## Authentication & Authorization

**Protect all endpoints:**

```typescript
// Auth middleware
function requireAuth(req: Request, res: Response, next: NextFunction) {
  const token = req.headers.authorization?.split(' ')[1];
  
  if (!token) {
    return res.status(401).json({ error: 'Authentication required' });
  }
  
  try {
    const user = verifyToken(token);
    req.user = user;
    next();
  } catch {
    return res.status(401).json({ error: 'Invalid token' });
  }
}

// Apply to protected routes
app.use('/api/users', requireAuth);
app.use('/api/admin', requireAuth, requireAdmin);
```

---

## Error Handling

**Secure error responses:**

```typescript
// Global error handler
app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
  // Log full error internally
  logger.error('API Error', {
    error: err.message,
    stack: err.stack,
    path: req.path,
    method: req.method,
    userId: req.user?.id,
  });
  
  // Return generic message
  if (err instanceof ValidationError) {
    return res.status(400).json({ error: 'Invalid request' });
  }
  
  if (err instanceof AuthError) {
    return res.status(401).json({ error: 'Authentication failed' });
  }
  
  // Generic server error
  res.status(500).json({ error: 'Internal server error' });
});
```

---

## Anti-Patterns to Avoid

- ❌ No rate limiting
- ❌ CORS `origin: '*'` with credentials
- ❌ Missing security headers
- ❌ Stack traces in production errors
- ❌ No request size limits
- ❌ Unprotected admin endpoints
- ❌ No logging of security events

---

## Security Checklist

- [ ] Rate limiting on all endpoints
- [ ] Stricter limits on auth endpoints
- [ ] CORS configured properly
- [ ] Security headers applied (helmet)
- [ ] CSRF protection for forms
- [ ] Request size limits set
- [ ] All routes require authentication
- [ ] Error responses don't leak internals
- [ ] Security events logged
- [ ] API versioning implemented

---

## Related Files

- **Rules:**
  - [authentication.mdc](./authentication.mdc) - Auth implementation
  - [input-validation.mdc](./input-validation.mdc) - Request validation
  - [../api/api-routes.mdc](../api/api-routes.mdc) - API patterns
- **Commands:**
  - [audit-security.md](../../commands/audit-security.md) - Security audit
