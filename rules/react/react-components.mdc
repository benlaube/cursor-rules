---
description: React component standards for building maintainable, performant UI components. This rule covers component structure, props handling, composition patterns, and TypeScript integration. Agents must use functional components, define proper prop types, implement composition over inheritance, and follow React best practices.
version: 1.0.0
created: 12-08-2025
lastUpdated: 12-08-2025 10:00:00 EST
alwaysApply: false
globs: **/*.tsx,**/components/**
type: Tech Stack Rule - React components
applicability: React component development
dependencies: []
relatedCommands: []
relatedRules: [[react-hooks.mdc], [react-performance.mdc], [../typescript/typescript-config.mdc]]
relatedStandards: []
---

# React Components Rule

## When This Rule Applies

This rule applies when:
- Creating React components
- Defining component props
- Structuring component files
- Reviewing React code

---

## Component Structure

### Basic Component

```tsx
import { type FC } from 'react';

interface ButtonProps {
  variant?: 'primary' | 'secondary' | 'danger';
  size?: 'sm' | 'md' | 'lg';
  disabled?: boolean;
  onClick?: () => void;
  children: React.ReactNode;
}

export const Button: FC<ButtonProps> = ({
  variant = 'primary',
  size = 'md',
  disabled = false,
  onClick,
  children,
}) => {
  return (
    <button
      className={cn(
        'rounded font-medium transition-colors',
        variants[variant],
        sizes[size],
        disabled && 'opacity-50 cursor-not-allowed'
      )}
      disabled={disabled}
      onClick={onClick}
    >
      {children}
    </button>
  );
};
```

### File Structure

```
components/
  Button/
    Button.tsx        # Component
    Button.test.tsx   # Tests
    index.ts          # Export
  Card/
    Card.tsx
    CardHeader.tsx
    CardContent.tsx
    index.ts
```

---

## Props Patterns

### Children Props

```tsx
interface CardProps {
  children: React.ReactNode;
}

// With specific children
interface ModalProps {
  children: React.ReactElement<typeof ModalContent>;
}
```

### Event Handlers

```tsx
interface InputProps {
  value: string;
  onChange: (value: string) => void;
  onBlur?: () => void;
}

export const Input: FC<InputProps> = ({ value, onChange, onBlur }) => (
  <input
    value={value}
    onChange={(e) => onChange(e.target.value)}
    onBlur={onBlur}
  />
);
```

### Render Props

```tsx
interface DataListProps<T> {
  data: T[];
  renderItem: (item: T, index: number) => React.ReactNode;
  keyExtractor: (item: T) => string;
}

export function DataList<T>({ data, renderItem, keyExtractor }: DataListProps<T>) {
  return (
    <ul>
      {data.map((item, index) => (
        <li key={keyExtractor(item)}>{renderItem(item, index)}</li>
      ))}
    </ul>
  );
}
```

---

## Composition Patterns

### Compound Components

```tsx
interface TabsContextValue {
  activeTab: string;
  setActiveTab: (tab: string) => void;
}

const TabsContext = createContext<TabsContextValue | null>(null);

function Tabs({ children, defaultTab }: { children: React.ReactNode; defaultTab: string }) {
  const [activeTab, setActiveTab] = useState(defaultTab);
  
  return (
    <TabsContext.Provider value={{ activeTab, setActiveTab }}>
      <div className="tabs">{children}</div>
    </TabsContext.Provider>
  );
}

function TabList({ children }: { children: React.ReactNode }) {
  return <div className="tab-list">{children}</div>;
}

function Tab({ value, children }: { value: string; children: React.ReactNode }) {
  const context = useContext(TabsContext);
  if (!context) throw new Error('Tab must be used within Tabs');
  
  return (
    <button
      className={cn('tab', context.activeTab === value && 'active')}
      onClick={() => context.setActiveTab(value)}
    >
      {children}
    </button>
  );
}

// Usage
<Tabs defaultTab="profile">
  <TabList>
    <Tab value="profile">Profile</Tab>
    <Tab value="settings">Settings</Tab>
  </TabList>
</Tabs>
```

### Forwarding Refs

```tsx
interface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {
  label?: string;
}

export const Input = forwardRef<HTMLInputElement, InputProps>(
  ({ label, className, ...props }, ref) => {
    return (
      <div>
        {label && <label>{label}</label>}
        <input ref={ref} className={cn('input', className)} {...props} />
      </div>
    );
  }
);

Input.displayName = 'Input';
```

---

## Data Attributes for Testing

```tsx
<button data-testid="submit-button" onClick={handleSubmit}>
  Submit
</button>

<input data-testid="email-input" type="email" />
```

---

## Anti-Patterns to Avoid

- ❌ Class components (use functional)
- ❌ Inline object/function props
- ❌ Direct DOM manipulation
- ❌ Props drilling (use context)
- ❌ Overly large components (>200 lines)
- ❌ Business logic in components

---

## Checklist

- [ ] Functional components only
- [ ] Props interface defined
- [ ] Default props specified
- [ ] displayName for forwardRef
- [ ] data-testid for testing
- [ ] Composition over inheritance

---

## Related Files

- **Rules:**
  - [react-hooks.mdc](./react-hooks.mdc) - React hooks patterns
  - [react-performance.mdc](./react-performance.mdc) - Performance optimization
  - [../typescript/typescript-config.mdc](../typescript/typescript-config.mdc) - TypeScript with React
