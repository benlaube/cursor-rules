---
description: React hooks standards for state management, side effects, and custom hooks. This rule covers useState, useEffect, useMemo, useCallback, and custom hook patterns. Agents must follow hooks rules, use appropriate hooks for use cases, implement custom hooks for reusable logic, and optimize re-renders.
version: 1.0.0
created: 12-08-2025
lastUpdated: 12-08-2025 10:00:00 EST
alwaysApply: false
globs: **/*.tsx,**/hooks/**
type: Tech Stack Rule - React hooks
applicability: React hooks usage
dependencies: []
relatedCommands: []
relatedRules: [[react-components.mdc], [react-performance.mdc]]
relatedStandards: []
---

# React Hooks Rule

## When This Rule Applies

This rule applies when:
- Using React hooks
- Creating custom hooks
- Managing component state
- Handling side effects

---

## Core Hook Patterns

### useState

```tsx
// Simple state
const [count, setCount] = useState(0);

// Object state (use reducer for complex)
const [form, setForm] = useState({
  email: '',
  password: '',
});

// Update single field
const updateField = (field: string, value: string) => {
  setForm(prev => ({ ...prev, [field]: value }));
};

// Lazy initialization
const [data] = useState(() => expensiveComputation());
```

### useEffect

```tsx
// Data fetching
useEffect(() => {
  const controller = new AbortController();
  
  async function fetchData() {
    try {
      const res = await fetch(url, { signal: controller.signal });
      setData(await res.json());
    } catch (err) {
      if (err.name !== 'AbortError') {
        setError(err);
      }
    }
  }
  
  fetchData();
  
  return () => controller.abort(); // Cleanup
}, [url]);

// Subscriptions
useEffect(() => {
  const subscription = eventEmitter.subscribe(handler);
  return () => subscription.unsubscribe();
}, []);
```

### useCallback

```tsx
// Memoize callbacks passed to children
const handleClick = useCallback(() => {
  doSomething(id);
}, [id]);

// For event handlers with dependencies
const handleSubmit = useCallback(async (data: FormData) => {
  await submitForm(data);
  onSuccess();
}, [onSuccess]);
```

### useMemo

```tsx
// Expensive computations
const sortedItems = useMemo(() => {
  return items.slice().sort((a, b) => a.name.localeCompare(b.name));
}, [items]);

// Object references
const config = useMemo(() => ({
  theme,
  locale,
}), [theme, locale]);
```

---

## Custom Hooks

### Data Fetching Hook

```tsx
interface UseQueryResult<T> {
  data: T | null;
  isLoading: boolean;
  error: Error | null;
  refetch: () => void;
}

function useQuery<T>(url: string): UseQueryResult<T> {
  const [data, setData] = useState<T | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);
  
  const fetchData = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    
    try {
      const res = await fetch(url);
      if (!res.ok) throw new Error('Failed to fetch');
      setData(await res.json());
    } catch (err) {
      setError(err as Error);
    } finally {
      setIsLoading(false);
    }
  }, [url]);
  
  useEffect(() => {
    fetchData();
  }, [fetchData]);
  
  return { data, isLoading, error, refetch: fetchData };
}
```

### Form Hook

```tsx
function useForm<T extends Record<string, any>>(initialValues: T) {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState<Partial<Record<keyof T, string>>>({});
  
  const handleChange = useCallback((field: keyof T, value: T[keyof T]) => {
    setValues(prev => ({ ...prev, [field]: value }));
    setErrors(prev => ({ ...prev, [field]: undefined }));
  }, []);
  
  const reset = useCallback(() => {
    setValues(initialValues);
    setErrors({});
  }, [initialValues]);
  
  return { values, errors, handleChange, setErrors, reset };
}
```

### Toggle Hook

```tsx
function useToggle(initial = false): [boolean, () => void] {
  const [value, setValue] = useState(initial);
  const toggle = useCallback(() => setValue(v => !v), []);
  return [value, toggle];
}
```

---

## Rules of Hooks

1. **Only call at top level** - No loops, conditions, nested functions
2. **Only call in React functions** - Components or custom hooks
3. **Use ESLint plugin** - `eslint-plugin-react-hooks`

```tsx
// Bad
if (condition) {
  const [state, setState] = useState(null); // ❌
}

// Good
const [state, setState] = useState(null);
if (condition) {
  // use state here
}
```

---

## Anti-Patterns to Avoid

- ❌ Missing dependencies in useEffect
- ❌ Object/array literals as deps
- ❌ Infinite loops in useEffect
- ❌ Unnecessary useCallback/useMemo
- ❌ State for derived values
- ❌ Complex state without useReducer

---

## Checklist

- [ ] Dependencies array correct
- [ ] Cleanup functions provided
- [ ] Custom hooks prefixed with "use"
- [ ] No rules violations
- [ ] Memoization used appropriately

---

## Related Files

- **Rules:**
  - [react-components.mdc](./react-components.mdc) - Component patterns
  - [react-performance.mdc](./react-performance.mdc) - Performance optimization
