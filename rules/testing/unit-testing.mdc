---
description: Unit testing standards for writing effective, maintainable unit tests. This rule covers test structure, naming conventions, mocking strategies, assertion patterns, and code coverage requirements. Agents must write tests that are isolated, fast, and deterministic, use descriptive test names, mock external dependencies, and maintain adequate code coverage.
version: 1.0.0
created: 12-08-2025
lastUpdated: 12-08-2025 10:00:00 EST
alwaysApply: false
globs: **/*.test.{ts,tsx,js,jsx},**/*.spec.{ts,tsx,js,jsx},**/test/**,**/tests/**,**/__tests__/**
type: Testing Rule - Unit testing standards
applicability: Unit test development
dependencies: []
relatedCommands: []
relatedRules: [[integration-testing.mdc], [test-data-management.mdc]]
relatedStandards: []
---

# Unit Testing Rule

## When This Rule Applies

This rule applies when:
- Writing unit tests
- Reviewing test code
- Setting up test infrastructure
- Debugging failing tests

---

## Core Principles

1. **Isolation** - Test one thing at a time
2. **Fast** - Tests should run in milliseconds
3. **Deterministic** - Same result every time
4. **Readable** - Tests are documentation

---

## Test Structure

### AAA Pattern (Arrange, Act, Assert)

```typescript
describe('UserService', () => {
  describe('createUser', () => {
    it('should create a user with valid input', async () => {
      // Arrange
      const input = { email: 'test@example.com', name: 'Test User' };
      const mockDb = createMockDb();
      const service = new UserService(mockDb);
      
      // Act
      const result = await service.createUser(input);
      
      // Assert
      expect(result.email).toBe(input.email);
      expect(result.name).toBe(input.name);
      expect(result.id).toBeDefined();
    });
  });
});
```

### Naming Conventions

```typescript
// Good: Descriptive names
it('should throw ValidationError when email is invalid')
it('should return null when user not found')
it('should hash password before saving')

// Bad: Vague names
it('works')
it('handles error')
it('test createUser')
```

---

## Mocking Strategies

### Mock External Dependencies

```typescript
// Good: Mock database
const mockDb = {
  users: {
    create: jest.fn().mockResolvedValue({ id: '123', ...userData }),
    findById: jest.fn().mockResolvedValue(null),
  },
};

// Good: Mock API client
jest.mock('../api/client', () => ({
  fetchUser: jest.fn().mockResolvedValue({ id: '123', name: 'Test' }),
}));
```

### Don't Mock What You're Testing

```typescript
// Bad: Mocking the thing you're testing
jest.mock('./userService');
const result = await userService.createUser(input);

// Good: Mock dependencies, test the actual function
const mockDb = createMockDb();
const service = new UserService(mockDb);
const result = await service.createUser(input);
```

---

## Assertion Patterns

### Use Specific Assertions

```typescript
// Good: Specific assertions
expect(user.email).toBe('test@example.com');
expect(users).toHaveLength(3);
expect(error).toBeInstanceOf(ValidationError);

// Bad: Generic assertions
expect(user).toBeTruthy();
expect(users.length > 0).toBe(true);
```

### Test Edge Cases

```typescript
describe('divide', () => {
  it('should divide two numbers', () => {
    expect(divide(10, 2)).toBe(5);
  });
  
  it('should handle decimal results', () => {
    expect(divide(1, 3)).toBeCloseTo(0.333, 2);
  });
  
  it('should throw when dividing by zero', () => {
    expect(() => divide(10, 0)).toThrow('Cannot divide by zero');
  });
  
  it('should handle negative numbers', () => {
    expect(divide(-10, 2)).toBe(-5);
  });
});
```

---

## Test Organization

### File Structure

```
src/
  services/
    user-service.ts
    user-service.test.ts    # Co-located tests
tests/
  integration/              # Integration tests
  e2e/                      # E2E tests
```

### Test Grouping

```typescript
describe('UserService', () => {
  describe('createUser', () => {
    it('should create user with valid input', () => {});
    it('should throw on invalid email', () => {});
  });
  
  describe('updateUser', () => {
    it('should update existing user', () => {});
    it('should throw when user not found', () => {});
  });
});
```

---

## Coverage Requirements

### Minimum Coverage

- **Statements:** 80%
- **Branches:** 75%
- **Functions:** 80%
- **Lines:** 80%

### Coverage Configuration

```json
// jest.config.js
{
  "coverageThreshold": {
    "global": {
      "statements": 80,
      "branches": 75,
      "functions": 80,
      "lines": 80
    }
  }
}
```

---

## Anti-Patterns to Avoid

- ❌ Testing implementation details
- ❌ Tests that depend on other tests
- ❌ Non-deterministic tests (dates, random)
- ❌ Testing third-party libraries
- ❌ Too many assertions per test
- ❌ No cleanup after tests
- ❌ Snapshot testing for logic

---

## Security Checklist

- [ ] Tests follow AAA pattern
- [ ] Descriptive test names
- [ ] External dependencies mocked
- [ ] Edge cases covered
- [ ] Tests are isolated
- [ ] Coverage meets threshold
- [ ] No flaky tests

---

## Related Files

- **Rules:**
  - [integration-testing.mdc](./integration-testing.mdc) - Integration tests
  - [test-data-management.mdc](./test-data-management.mdc) - Test data patterns
